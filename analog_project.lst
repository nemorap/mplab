CCS PCH C Compiler, Version 4.120, 36728               01-abr.-17 16:49

               Filename: D:\Plantilla_base\analog_project.lst

               ROM used: 7182 bytes (5%)
                         Largest free fragment is 65528
               RAM used: 1227 (33%) at main() level
                         1250 (33%) worst case
               Stack:    3 locations

*
01000:  GOTO   2688
.................... #include "EMm47J53_StackConfig.h" 
.................... /* 
.................... ** ########################################################################## 
.................... **     Filename  : EMm47J53_StackConfig.h 
.................... **     Processor : PIC18F47J53 
.................... **     FileFormat: V1.00 
.................... **     DataSheet : PIC18F47J53 
.................... **     Compiler  : CCS Compiler V4.114 
.................... **     Date/Time : 14.12.2011, 11:00 
.................... ** 
.................... ** 
.................... ** 
.................... ** 
.................... **     (c) Copyright OCTOPLUS.2008-2011 
.................... **     OCTOPLUS.  
.................... **     Ernesto Andres Rincon Cruz 
.................... **     Republica de Colombia 
.................... **     http      : www.octoplusaz.com 
.................... **     mail      : soporte@octoplusaz.com 
.................... **  
.................... ** 
.................... **     Nota:  Todas las funciones estan debidamente probadas usando el  
.................... **            modulo EMm47J53 corriendo a una frecuencia de bus interno  
.................... **            de 12MHz. Para mas informacion www.octoplusaz.com/foros 
.................... ** ########################################################################### 
.................... */ 
.................... #ifndef _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #define _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
01CD4:  MOVLW  04
01CD6:  MOVWF  FEA
01CD8:  MOVLW  C9
01CDA:  MOVWF  FE9
01CDC:  MOVF   FEF,W
01CDE:  BZ    1CFC
01CE0:  MOVLW  0F
01CE2:  MOVWF  01
01CE4:  CLRF   00
01CE6:  DECFSZ 00,F
01CE8:  BRA    1CE6
01CEA:  DECFSZ 01,F
01CEC:  BRA    1CE4
01CEE:  MOVLW  8F
01CF0:  MOVWF  00
01CF2:  DECFSZ 00,F
01CF4:  BRA    1CF2
01CF6:  NOP   
01CF8:  DECFSZ FEF,F
01CFA:  BRA    1CE0
01CFC:  RETURN 0
*
01DEC:  MOVLW  01
01DEE:  MOVLB  4
01DF0:  SUBWF  xC8,F
01DF2:  BNC   1E0E
01DF4:  MOVLW  04
01DF6:  MOVWF  FEA
01DF8:  MOVLW  C8
01DFA:  MOVWF  FE9
01DFC:  MOVF   FEF,W
01DFE:  BZ    1E0E
01E00:  MOVLW  02
01E02:  MOVWF  00
01E04:  DECFSZ 00,F
01E06:  BRA    1E04
01E08:  BRA    1E0A
01E0A:  DECFSZ FEF,F
01E0C:  BRA    1E00
01E0E:  MOVLB  0
01E10:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................  PLLEN = 1;          /*Habilita PLL para generar 48MHz de oscilador*/\ 
.................... }while(0) 
....................  
.................... #endif /* _INC_OCTOPLUS_STACK_CONFIG_H */ 
....................  
.................... //======================================================== 
.................... // Nombre del Programa: Manejo del LCD GRAFICO 128x64 
.................... // Autor: Claudia Leonor Rueda Guzmán 
.................... // UNIVERSIDAD PONTIFICIA BOLIVARIANA 
.................... //======================================================== 
....................  
....................  
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
....................  
.................... #define GLCD_DI      PIN_E1   // Data or Instruction input (RS) 
.................... #define GLCD_RW      PIN_C1   // Read/Write 
.................... #define GLCD_E       PIN_C2   // Enable 
.................... #define GLCD_DB0     PIN_D0   // Data0 
.................... #define GLCD_DB1     PIN_D1   // Data1 
.................... #define GLCD_DB2     PIN_D2   // Data2 
.................... #define GLCD_DB3     PIN_D3   // Data3 
.................... #define GLCD_DB4     PIN_D4   // Data4 
.................... #define GLCD_DB5     PIN_D5   // Data5 
.................... #define GLCD_DB6     PIN_D6   // Data6 
.................... #define GLCD_DB7     PIN_D7   // Data7 
.................... #define GLCD_CS2     PIN_E0   // Chip Selection 1 
.................... #define GLCD_CS1     PIN_C7   // Chip Selection 2 
.................... #define GLCD_RST     PIN_C6   // Reset 
....................  
.................... #define ventilador    PIN_A3 
....................  
.................... #define ON           1 
.................... #define OFF          0 
....................  
.................... #define  FAST_GLCD 
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
.................... char  text_glcd[40]; 
.................... char  last_key=0x00; 
.................... char  last_screen; 
.................... float calculo, temp, prom; 
.................... unsigned char sensor1, sensor2, sensor3; 
.................... signed int vector[120]; 
.................... signed int dato,posy=55,aux,x,t,i; 
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
....................  
.................... #include "GLCD_128x64_KS0108.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    unsigned int8 left[512]; 
....................    unsigned int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
01844:  BCF    F94.6
01846:  BSF    F8B.6
....................    output_low(GLCD_E); 
01848:  BCF    F94.2
0184A:  BCF    F8B.2
....................    output_low(GLCD_CS1); 
0184C:  BCF    F94.7
0184E:  BCF    F8B.7
....................    output_low(GLCD_CS2); 
01850:  BCF    F96.0
01852:  BCF    F8D.0
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
01854:  BCF    F96.1
01856:  BCF    F8D.1
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
01858:  MOVLB  4
0185A:  CLRF   xD0
0185C:  MOVLW  C0
0185E:  MOVWF  xD1
01860:  MOVLB  0
01862:  RCALL  165C
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
01864:  MOVLW  01
01866:  MOVLB  4
01868:  MOVWF  xD0
0186A:  MOVLW  C0
0186C:  MOVWF  xD1
0186E:  MOVLB  0
01870:  RCALL  165C
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
01872:  MOVLB  4
01874:  CLRF   xD0
01876:  MOVLW  40
01878:  MOVWF  xD1
0187A:  MOVLB  0
0187C:  RCALL  165C
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
0187E:  MOVLW  01
01880:  MOVLB  4
01882:  MOVWF  xD0
01884:  MOVLW  40
01886:  MOVWF  xD1
01888:  MOVLB  0
0188A:  RCALL  165C
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0188C:  MOVLB  4
0188E:  CLRF   xD0
01890:  MOVLW  B8
01892:  MOVWF  xD1
01894:  MOVLB  0
01896:  RCALL  165C
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
01898:  MOVLW  01
0189A:  MOVLB  4
0189C:  MOVWF  xD0
0189E:  MOVLW  B8
018A0:  MOVWF  xD1
018A2:  MOVLB  0
018A4:  RCALL  165C
....................  
....................    if(mode == ON) 
018A6:  MOVLB  4
018A8:  DECFSZ xC8,W
018AA:  BRA    18C8
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
018AC:  CLRF   xD0
018AE:  MOVLW  3F
018B0:  MOVWF  xD1
018B2:  MOVLB  0
018B4:  RCALL  165C
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
018B6:  MOVLW  01
018B8:  MOVLB  4
018BA:  MOVWF  xD0
018BC:  MOVLW  3F
018BE:  MOVWF  xD1
018C0:  MOVLB  0
018C2:  RCALL  165C
....................    } 
....................    else 
018C4:  BRA    18E0
018C6:  MOVLB  4
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
018C8:  CLRF   xD0
018CA:  MOVLW  3E
018CC:  MOVWF  xD1
018CE:  MOVLB  0
018D0:  RCALL  165C
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
018D2:  MOVLW  01
018D4:  MOVLB  4
018D6:  MOVWF  xD0
018D8:  MOVLW  3E
018DA:  MOVWF  xD1
018DC:  MOVLB  0
018DE:  RCALL  165C
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
018E0:  MOVLB  4
018E2:  CLRF   xD2
018E4:  MOVLB  0
018E6:  RCALL  1732
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
018E8:  RCALL  178C
....................    #endif 
.................... } 
018EA:  GOTO   2736 (RETURN)
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    unsigned int8 i, j; 
....................    unsigned int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
*
0178C:  MOVLB  4
0178E:  CLRF   xCC
01790:  MOVLW  BB
01792:  MOVWF  xCB
....................    p2 = displayData.right; 
01794:  MOVLW  02
01796:  MOVWF  xCE
01798:  MOVLW  BB
0179A:  MOVWF  xCD
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
0179C:  CLRF   xC9
0179E:  MOVF   xC9,W
017A0:  SUBLW  07
017A2:  BNC   1840
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
017A4:  BCF    F96.1
017A6:  BCF    F8D.1
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
017A8:  CLRF   xD0
017AA:  MOVLW  40
017AC:  MOVWF  xD1
017AE:  MOVLB  0
017B0:  RCALL  165C
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
017B2:  MOVLW  01
017B4:  MOVLB  4
017B6:  MOVWF  xD0
017B8:  MOVLW  40
017BA:  MOVWF  xD1
017BC:  MOVLB  0
017BE:  RCALL  165C
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
017C0:  MOVLB  4
017C2:  MOVF   xC9,W
017C4:  IORLW  B8
017C6:  MOVWF  xCF
017C8:  CLRF   xD0
017CA:  MOVWF  xD1
017CC:  MOVLB  0
017CE:  RCALL  165C
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
017D0:  MOVLB  4
017D2:  MOVF   xC9,W
017D4:  IORLW  B8
017D6:  MOVWF  xCF
017D8:  MOVLW  01
017DA:  MOVWF  xD0
017DC:  MOVFF  4CF,4D1
017E0:  MOVLB  0
017E2:  RCALL  165C
....................       output_high(GLCD_DI);                     // Set for data 
017E4:  BCF    F96.1
017E6:  BSF    F8D.1
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
017E8:  MOVLB  4
017EA:  CLRF   xCA
017EC:  MOVF   xCA,W
017EE:  SUBLW  3F
017F0:  BNC   183C
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
017F2:  MOVFF  4CC,03
017F6:  MOVF   xCB,W
017F8:  INCF   xCB,F
017FA:  BTFSC  FD8.2
017FC:  INCF   xCC,F
017FE:  MOVWF  FE9
01800:  MOVFF  03,FEA
01804:  MOVFF  FEF,4CF
01808:  CLRF   xD0
0180A:  MOVFF  4CF,4D1
0180E:  MOVLB  0
01810:  RCALL  165C
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
01812:  MOVLB  4
01814:  MOVFF  4CE,03
01818:  MOVF   xCD,W
0181A:  INCF   xCD,F
0181C:  BTFSC  FD8.2
0181E:  INCF   xCE,F
01820:  MOVWF  FE9
01822:  MOVFF  03,FEA
01826:  MOVFF  FEF,4CF
0182A:  MOVLW  01
0182C:  MOVWF  xD0
0182E:  MOVFF  4CF,4D1
01832:  MOVLB  0
01834:  RCALL  165C
....................       } 
01836:  MOVLB  4
01838:  INCF   xCA,F
0183A:  BRA    17EC
....................    } 
0183C:  INCF   xC9,F
0183E:  BRA    179E
.................... } 
01840:  MOVLB  0
01842:  RETURN 0
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8* p; 
....................    unsigned int16 temp; 
....................    temp =  y/8; 
*
01936:  MOVLB  4
01938:  CLRF   xDF
0193A:  RRCF   xDA,W
0193C:  MOVWF  xDE
0193E:  RRCF   xDE,F
01940:  RRCF   xDE,F
01942:  MOVLW  1F
01944:  ANDWF  xDE,F
....................    temp *= 64; 
01946:  RLCF   xDE,F
01948:  RLCF   xDF,F
0194A:  RLCF   xDE,F
0194C:  RLCF   xDF,F
0194E:  RLCF   xDE,F
01950:  RLCF   xDF,F
01952:  RLCF   xDE,F
01954:  RLCF   xDF,F
01956:  RLCF   xDE,F
01958:  RLCF   xDF,F
0195A:  RLCF   xDE,F
0195C:  RLCF   xDF,F
0195E:  MOVLW  C0
01960:  ANDWF  xDE,F
....................    temp += x; 
01962:  MOVF   xD9,W
01964:  ADDWF  xDE,F
01966:  MOVLW  00
01968:  ADDWFC xDF,F
....................  
....................    if(x > 63) 
0196A:  MOVF   xD9,W
0196C:  SUBLW  3F
0196E:  BC    198A
....................    { 
....................       p = displayData.right + temp - 64; 
01970:  MOVLW  BB
01972:  ADDWF  xDE,W
01974:  MOVWF  xE0
01976:  MOVLW  02
01978:  ADDWFC xDF,W
0197A:  MOVWF  xE1
0197C:  MOVLW  40
0197E:  SUBWF  xE0,W
01980:  MOVWF  xDC
01982:  MOVLW  00
01984:  SUBWFB xE1,W
01986:  MOVWF  xDD
....................    } 
....................    else 
01988:  BRA    1996
....................    { 
....................       p = displayData.left + temp; 
0198A:  MOVLW  BB
0198C:  ADDWF  xDE,W
0198E:  MOVWF  xDC
01990:  MOVLW  00
01992:  ADDWFC xDF,W
01994:  MOVWF  xDD
....................    } 
....................  
....................    if(color) 
01996:  MOVF   xDB,F
01998:  BZ    19C4
....................    { 
....................       bit_set(*p, y%8); 
0199A:  MOVFF  4DD,03
0199E:  MOVFF  4DC,FE9
019A2:  MOVFF  4DD,FEA
019A6:  MOVF   xDA,W
019A8:  ANDLW  07
019AA:  MOVWF  xE0
019AC:  MOVLW  01
019AE:  MOVWF  00
019B0:  MOVF   xE0,W
019B2:  MOVWF  01
019B4:  BZ    19BE
019B6:  BCF    FD8.0
019B8:  RLCF   00,F
019BA:  DECFSZ 01,F
019BC:  BRA    19B6
019BE:  MOVF   00,W
019C0:  IORWF  FEF,F
....................    } 
....................    else 
019C2:  BRA    19EE
....................    { 
....................       bit_clear(*p, y%8); 
019C4:  MOVFF  4DD,03
019C8:  MOVFF  4DC,FE9
019CC:  MOVFF  4DD,FEA
019D0:  MOVF   xDA,W
019D2:  ANDLW  07
019D4:  MOVWF  xE0
019D6:  MOVLW  01
019D8:  MOVWF  00
019DA:  MOVF   xE0,W
019DC:  MOVWF  01
019DE:  BZ    19E8
019E0:  BCF    FD8.0
019E2:  RLCF   00,F
019E4:  DECFSZ 01,F
019E6:  BRA    19E0
019E8:  MOVF   00,W
019EA:  XORLW  FF
019EC:  ANDWF  FEF,F
....................    } 
.................... } 
019EE:  MOVLB  0
019F0:  RETURN 0
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
....................    { 
....................       x -= 64; 
....................       side = GLCD_RIGHT; 
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
....................    output_high(GLCD_DI);                        // Set for data 
....................    glcd_readByte(side);                         // Need two reads to get data 
....................    data = glcd_readByte(side);                  //  at new address 
....................  
....................    if(color == ON) 
....................       bit_set(data, y%8);        // Turn the pixel on 
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
....................    glcd_writeByte(side, x);      // Set the horizontal address 
....................    output_high(GLCD_DI);         // Set for data 
....................    glcd_writeByte(side, data);   // Write the pixel data 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    unsigned int8  data; 
....................    unsigned int8  *p1, *p2; 
....................    unsigned int16 i; 
....................  
....................    p1 = displayData.left; 
*
01732:  MOVLB  4
01734:  CLRF   xD5
01736:  MOVLW  BB
01738:  MOVWF  xD4
....................    p2 = displayData.right; 
0173A:  MOVLW  02
0173C:  MOVWF  xD7
0173E:  MOVLW  BB
01740:  MOVWF  xD6
....................    data = 0xFF * color; 
01742:  MOVF   xD2,W
01744:  MULLW  FF
01746:  MOVFF  FF3,4D3
....................  
....................    for(i=0; i<512; ++i) 
0174A:  CLRF   xD9
0174C:  CLRF   xD8
0174E:  MOVF   xD9,W
01750:  SUBLW  01
01752:  BNC   1788
....................    { 
....................       *p1++ = data; 
01754:  MOVFF  4D5,03
01758:  MOVF   xD4,W
0175A:  INCF   xD4,F
0175C:  BTFSC  FD8.2
0175E:  INCF   xD5,F
01760:  MOVWF  FE9
01762:  MOVFF  03,FEA
01766:  MOVFF  4D3,FEF
....................       *p2++ = data; 
0176A:  MOVFF  4D7,03
0176E:  MOVF   xD6,W
01770:  INCF   xD6,F
01772:  BTFSC  FD8.2
01774:  INCF   xD7,F
01776:  MOVWF  FE9
01778:  MOVFF  03,FEA
0177C:  MOVFF  4D3,FEF
....................    } 
01780:  INCF   xD8,F
01782:  BTFSC  FD8.2
01784:  INCF   xD9,F
01786:  BRA    174E
.................... } 
01788:  MOVLB  0
0178A:  RETURN 0
.................... #else 
.................... { 
....................    unsigned int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    output_low(GLCD_DB0); 
*
0165C:  BCF    F95.0
0165E:  BCF    F8C.0
....................    output_low(GLCD_DB1); 
01660:  BCF    F95.1
01662:  BCF    F8C.1
....................    output_low(GLCD_DB2); 
01664:  BCF    F95.2
01666:  BCF    F8C.2
....................    output_low(GLCD_DB3); 
01668:  BCF    F95.3
0166A:  BCF    F8C.3
....................    output_low(GLCD_DB4); 
0166C:  BCF    F95.4
0166E:  BCF    F8C.4
....................    output_low(GLCD_DB5); 
01670:  BCF    F95.5
01672:  BCF    F8C.5
....................    output_low(GLCD_DB6); 
01674:  BCF    F95.6
01676:  BCF    F8C.6
....................    output_low(GLCD_DB7); 
01678:  BCF    F95.7
0167A:  BCF    F8C.7
....................     
....................    output_low(GLCD_RW);          // Set for writing 
0167C:  BCF    F94.1
0167E:  BCF    F8B.1
....................  
....................     if(side)                     // Choose which side to write to 
01680:  MOVLB  4
01682:  MOVF   xD0,F
01684:  BZ    168C
....................       output_high(GLCD_CS2); 
01686:  BCF    F96.0
01688:  BSF    F8D.0
....................    else 
0168A:  BRA    1690
....................       output_high(GLCD_CS1); 
0168C:  BCF    F94.7
0168E:  BSF    F8B.7
....................  
....................    delay_us(1); 
01690:  MOVLW  03
01692:  MOVWF  00
01694:  DECFSZ 00,F
01696:  BRA    1694
01698:  BRA    169A
....................  
....................    if(bit_test(data,0)==1)output_high (GLCD_DB0); 
0169A:  BTFSS  xD1.0
0169C:  BRA    16A4
0169E:  BCF    F95.0
016A0:  BSF    F8C.0
....................    else output_low (GLCD_DB0); 
016A2:  BRA    16A8
016A4:  BCF    F95.0
016A6:  BCF    F8C.0
....................     
....................    if(bit_test(data,1)==1)output_high (GLCD_DB1); 
016A8:  BTFSS  xD1.1
016AA:  BRA    16B2
016AC:  BCF    F95.1
016AE:  BSF    F8C.1
....................    else output_low (GLCD_DB1); 
016B0:  BRA    16B6
016B2:  BCF    F95.1
016B4:  BCF    F8C.1
....................     
....................    if(bit_test(data,2)==1)output_high (GLCD_DB2); 
016B6:  BTFSS  xD1.2
016B8:  BRA    16C0
016BA:  BCF    F95.2
016BC:  BSF    F8C.2
....................    else output_low (GLCD_DB2); 
016BE:  BRA    16C4
016C0:  BCF    F95.2
016C2:  BCF    F8C.2
....................     
....................    if(bit_test(data,3)==1)output_high (GLCD_DB3); 
016C4:  BTFSS  xD1.3
016C6:  BRA    16CE
016C8:  BCF    F95.3
016CA:  BSF    F8C.3
....................    else output_low (GLCD_DB3); 
016CC:  BRA    16D2
016CE:  BCF    F95.3
016D0:  BCF    F8C.3
....................     
....................    if(bit_test(data,4)==1)output_high (GLCD_DB4); 
016D2:  BTFSS  xD1.4
016D4:  BRA    16DC
016D6:  BCF    F95.4
016D8:  BSF    F8C.4
....................    else output_low (GLCD_DB4); 
016DA:  BRA    16E0
016DC:  BCF    F95.4
016DE:  BCF    F8C.4
....................     
....................    if(bit_test(data,5)==1)output_high (GLCD_DB5); 
016E0:  BTFSS  xD1.5
016E2:  BRA    16EA
016E4:  BCF    F95.5
016E6:  BSF    F8C.5
....................    else output_low (GLCD_DB5); 
016E8:  BRA    16EE
016EA:  BCF    F95.5
016EC:  BCF    F8C.5
....................     
....................    if(bit_test(data,6)==1)output_high (GLCD_DB6); 
016EE:  BTFSS  xD1.6
016F0:  BRA    16F8
016F2:  BCF    F95.6
016F4:  BSF    F8C.6
....................    else output_low (GLCD_DB6); 
016F6:  BRA    16FC
016F8:  BCF    F95.6
016FA:  BCF    F8C.6
....................     
....................    if(bit_test(data,7)==1)output_high (GLCD_DB7); 
016FC:  BTFSS  xD1.7
016FE:  BRA    1706
01700:  BCF    F95.7
01702:  BSF    F8C.7
....................    else output_low (GLCD_DB7); 
01704:  BRA    170A
01706:  BCF    F95.7
01708:  BCF    F8C.7
....................        
....................    delay_us(1); 
0170A:  MOVLW  03
0170C:  MOVWF  00
0170E:  DECFSZ 00,F
01710:  BRA    170E
01712:  BRA    1714
....................    output_high(GLCD_E);          // Pulse the enable pin 
01714:  BCF    F94.2
01716:  BSF    F8B.2
....................    delay_us(1); 
01718:  MOVLW  03
0171A:  MOVWF  00
0171C:  DECFSZ 00,F
0171E:  BRA    171C
01720:  BRA    1722
....................    output_low(GLCD_E); 
01722:  BCF    F94.2
01724:  BCF    F8B.2
....................  
....................    output_low(GLCD_CS1);         // Reset the chip select lines 
01726:  BCF    F94.7
01728:  BCF    F8B.7
....................    output_low(GLCD_CS2); 
0172A:  BCF    F96.0
0172C:  BCF    F8D.0
.................... } 
0172E:  MOVLB  0
01730:  RETURN 0
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    (void) 
....................    (void)input(GLCD_DB1); 
....................    (void)input(GLCD_DB2); 
....................    (void)input(GLCD_DB3); 
....................    (void)input(GLCD_DB4); 
....................    (void)input(GLCD_DB5); 
....................    (void)input(GLCD_DB6); 
....................    (void)input(GLCD_DB7); 
....................     
....................    output_high(GLCD_RW);      // Set for reading 
....................  
....................    if(side)                   // Choose which side to write to 
....................       output_high(GLCD_CS2); 
....................    else 
....................       output_high(GLCD_CS1); 
....................  
....................    delay_us(1); 
....................    output_high(GLCD_E);       // Pulse the enable pin 
....................    delay_us(1); 
....................     
....................    data=0; 
....................       if(input(GLCD_DB0)==1)  bit_set(data,0); 
....................       if(input(GLCD_DB1)==1)  bit_set(data,1); 
....................       if(input(GLCD_DB2)==1)  bit_set(data,2); 
....................       if(input(GLCD_DB3)==1)  bit_set(data,3); 
....................       if(input(GLCD_DB4)==1)  bit_set(data,4); 
....................       if(input(GLCD_DB5)==1)  bit_set(data,5); 
....................       if(input(GLCD_DB6)==1)  bit_set(data,6); 
....................       if(input(GLCD_DB7)==1)  bit_set(data,7); 
....................        
....................    output_low(GLCD_E); 
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
....................    return data;               // Return the read data 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <graphics.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2010 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const unsigned int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, iunsigned nt16 y2, int1 color) 
.................... #else 
.................... void glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color) 
.................... #endif 
.................... { 
*
01B9A:  MOVLW  01
01B9C:  MOVLB  4
01B9E:  MOVWF  xD1
01BA0:  MOVWF  xD2
01BA2:  CLRF   xD7
....................    unsigned int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
01BA4:  MOVF   xC8,W
01BA6:  SUBWF  xCA,W
01BA8:  MOVWF  xD8
01BAA:  MOVF   xD8,W
01BAC:  BTFSS  xD8.7
01BAE:  BRA    1BB6
01BB0:  MOVLW  00
01BB2:  BSF    FD8.0
01BB4:  SUBFWB xD8,W
01BB6:  CLRF   03
01BB8:  MOVWF  xCF
01BBA:  MOVFF  03,4D0
....................    dy = abs((signed int8)(y2 - y1)); 
01BBE:  MOVF   xC9,W
01BC0:  SUBWF  xCB,W
01BC2:  MOVWF  xD8
01BC4:  MOVF   xD8,W
01BC6:  BTFSS  xD8.7
01BC8:  BRA    1BD0
01BCA:  MOVLW  00
01BCC:  BSF    FD8.0
01BCE:  SUBFWB xD8,W
01BD0:  CLRF   03
01BD2:  MOVWF  xCD
01BD4:  MOVFF  03,4CE
....................    #endif 
....................  
....................    if(x1 > x2) 
01BD8:  MOVF   xC8,W
01BDA:  SUBWF  xCA,W
01BDC:  BC    1BE0
....................       addx = -1; 
01BDE:  SETF   xD1
....................    if(y1 > y2) 
01BE0:  MOVF   xC9,W
01BE2:  SUBWF  xCB,W
01BE4:  BC    1BE8
....................       addy = -1; 
01BE6:  SETF   xD2
....................  
....................    if(dx >= dy) 
01BE8:  MOVF   xCE,W
01BEA:  SUBWF  xD0,W
01BEC:  BNC   1C64
01BEE:  BNZ   1BF6
01BF0:  MOVF   xCD,W
01BF2:  SUBWF  xCF,W
01BF4:  BNC   1C64
....................    { 
....................       dy *= 2; 
01BF6:  BCF    FD8.0
01BF8:  RLCF   xCD,F
01BFA:  RLCF   xCE,F
....................       P = dy - dx; 
01BFC:  MOVF   xCF,W
01BFE:  SUBWF  xCD,W
01C00:  MOVWF  00
01C02:  MOVF   xD0,W
01C04:  SUBWFB xCE,W
01C06:  MOVFF  00,4D3
01C0A:  MOVWF  xD4
....................       diff = P - dx; 
01C0C:  MOVF   xCF,W
01C0E:  SUBWF  xD3,W
01C10:  MOVWF  xD5
01C12:  MOVF   xD0,W
01C14:  SUBWFB xD4,W
01C16:  MOVWF  xD6
....................  
....................       for(; i<=dx; ++i) 
01C18:  MOVF   xD0,F
01C1A:  BNZ   1C22
01C1C:  MOVF   xD7,W
01C1E:  SUBWF  xCF,W
01C20:  BNC   1C62
....................       { 
....................          glcd_pixel(x1, y1, color); 
01C22:  MOVFF  4C8,4D9
01C26:  MOVFF  4C9,4DA
01C2A:  MOVFF  4CC,4DB
01C2E:  MOVLB  0
01C30:  RCALL  1936
....................  
....................          if(P < 0) 
01C32:  MOVLB  4
01C34:  BTFSC  xD4.7
01C36:  BRA    1C3A
01C38:  BRA    1C4A
....................          { 
....................             P  += dy; 
01C3A:  MOVF   xCD,W
01C3C:  ADDWF  xD3,F
01C3E:  MOVF   xCE,W
01C40:  ADDWFC xD4,F
....................             x1 += addx; 
01C42:  MOVF   xD1,W
01C44:  ADDWF  xC8,W
01C46:  MOVWF  xC8
....................          } 
....................          else 
01C48:  BRA    1C5E
....................          { 
....................             P  += diff; 
01C4A:  MOVF   xD5,W
01C4C:  ADDWF  xD3,F
01C4E:  MOVF   xD6,W
01C50:  ADDWFC xD4,F
....................             x1 += addx; 
01C52:  MOVF   xD1,W
01C54:  ADDWF  xC8,W
01C56:  MOVWF  xC8
....................             y1 += addy; 
01C58:  MOVF   xD2,W
01C5A:  ADDWF  xC9,W
01C5C:  MOVWF  xC9
....................          } 
....................       } 
01C5E:  INCF   xD7,F
01C60:  BRA    1C18
....................    } 
....................    else 
01C62:  BRA    1CD0
....................    { 
....................       dx *= 2; 
01C64:  BCF    FD8.0
01C66:  RLCF   xCF,F
01C68:  RLCF   xD0,F
....................       P = dx - dy; 
01C6A:  MOVF   xCD,W
01C6C:  SUBWF  xCF,W
01C6E:  MOVWF  00
01C70:  MOVF   xCE,W
01C72:  SUBWFB xD0,W
01C74:  MOVFF  00,4D3
01C78:  MOVWF  xD4
....................       diff = P - dy; 
01C7A:  MOVF   xCD,W
01C7C:  SUBWF  xD3,W
01C7E:  MOVWF  xD5
01C80:  MOVF   xCE,W
01C82:  SUBWFB xD4,W
01C84:  MOVWF  xD6
....................  
....................       for(; i<=dy; ++i) 
01C86:  MOVF   xCE,F
01C88:  BNZ   1C90
01C8A:  MOVF   xD7,W
01C8C:  SUBWF  xCD,W
01C8E:  BNC   1CD0
....................       { 
....................          glcd_pixel(x1, y1, color); 
01C90:  MOVFF  4C8,4D9
01C94:  MOVFF  4C9,4DA
01C98:  MOVFF  4CC,4DB
01C9C:  MOVLB  0
01C9E:  RCALL  1936
....................  
....................          if(P < 0) 
01CA0:  MOVLB  4
01CA2:  BTFSC  xD4.7
01CA4:  BRA    1CA8
01CA6:  BRA    1CB8
....................          { 
....................             P  += dx; 
01CA8:  MOVF   xCF,W
01CAA:  ADDWF  xD3,F
01CAC:  MOVF   xD0,W
01CAE:  ADDWFC xD4,F
....................             y1 += addy; 
01CB0:  MOVF   xD2,W
01CB2:  ADDWF  xC9,W
01CB4:  MOVWF  xC9
....................          } 
....................          else 
01CB6:  BRA    1CCC
....................          { 
....................             P  += diff; 
01CB8:  MOVF   xD5,W
01CBA:  ADDWF  xD3,F
01CBC:  MOVF   xD6,W
01CBE:  ADDWFC xD4,F
....................             x1 += addx; 
01CC0:  MOVF   xD1,W
01CC2:  ADDWF  xC8,W
01CC4:  MOVWF  xC8
....................             y1 += addy; 
01CC6:  MOVF   xD2,W
01CC8:  ADDWF  xC9,W
01CCA:  MOVWF  xC9
....................          } 
....................       } 
01CCC:  INCF   xD7,F
01CCE:  BRA    1C86
....................    } 
.................... } 
01CD0:  MOVLB  0
01CD2:  RETURN 0
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
....................    { 
....................       #ifdef LARGE_LCD 
....................       unsigned int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       unsigned int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
....................       { 
....................          xmin = x1; 
....................          xmax = x2; 
....................       } 
....................       else 
....................       { 
....................          xmin = x2; 
....................          xmax = x1; 
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
....................       { 
....................          ymin = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          ymin = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
....................          { 
....................             glcd_pixel(xmin, i, color); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(unsigned int16 x1, unsigned int16 y1, unsigned int16 x2, unsigned int16 y2, unsigned int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    unsigned int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    unsigned int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(unsigned int16 x, unsigned int16 y, unsigned int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(unsigned int16 x, unsigned int16 y, char* textptr, unsigned int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(unsigned int8 x, unsigned int8 y, char* textptr, unsigned int8 size, int1 color) 
.................... #endif 
.................... { 
....................    unsigned int8 j, k, l, m;                       // Loop counters 
....................    unsigned int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
019F2:  MOVFF  4CB,03
019F6:  MOVLB  4
019F8:  MOVFF  4CA,FE9
019FC:  MOVFF  4CB,FEA
01A00:  MOVF   FEF,F
01A02:  BTFSC  FD8.2
01A04:  BRA    1B96
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
01A06:  MOVFF  4CB,03
01A0A:  MOVFF  4CA,FE9
01A0E:  MOVFF  4CB,FEA
01A12:  MOVF   FEF,W
01A14:  SUBLW  52
01A16:  BNC   1A5C
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
01A18:  MOVFF  4CB,03
01A1C:  MOVFF  4CA,FE9
01A20:  MOVFF  4CB,FEA
01A24:  MOVLW  20
01A26:  SUBWF  FEF,W
01A28:  MULLW  05
01A2A:  MOVF   FF3,W
01A2C:  CLRF   03
01A2E:  MOVWF  xD7
01A30:  MOVLW  04
01A32:  MOVWF  FEA
01A34:  MOVLW  D2
01A36:  MOVWF  FE9
01A38:  CLRF   xDB
01A3A:  MOVFF  4D7,4DA
01A3E:  MOVLW  05
01A40:  MOVWF  01
01A42:  CLRF   FF7
01A44:  MOVF   xD7,W
01A46:  MOVLB  0
01A48:  CALL   1008
01A4C:  TBLRD*-
01A4E:  TBLRD*+
01A50:  MOVFF  FF5,FEE
01A54:  DECFSZ 01,F
01A56:  BRA    1A4E
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
01A58:  BRA    1ABE
01A5A:  MOVLB  4
01A5C:  MOVFF  4CB,03
01A60:  MOVFF  4CA,FE9
01A64:  MOVFF  4CB,FEA
01A68:  MOVF   FEF,W
01A6A:  SUBLW  7E
01A6C:  BNC   1AB2
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
01A6E:  MOVFF  4CB,03
01A72:  MOVFF  4CA,FE9
01A76:  MOVFF  4CB,FEA
01A7A:  MOVLW  53
01A7C:  SUBWF  FEF,W
01A7E:  MULLW  05
01A80:  MOVF   FF3,W
01A82:  CLRF   03
01A84:  MOVWF  xD7
01A86:  MOVLW  04
01A88:  MOVWF  FEA
01A8A:  MOVLW  D2
01A8C:  MOVWF  FE9
01A8E:  CLRF   xDB
01A90:  MOVFF  4D7,4DA
01A94:  MOVLW  05
01A96:  MOVWF  01
01A98:  CLRF   FF7
01A9A:  MOVF   xD7,W
01A9C:  MOVLB  0
01A9E:  CALL   111C
01AA2:  TBLRD*-
01AA4:  TBLRD*+
01AA6:  MOVFF  FF5,FEE
01AAA:  DECFSZ 01,F
01AAC:  BRA    1AA4
....................       else 
01AAE:  BRA    1ABE
01AB0:  MOVLB  4
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
01AB2:  CLRF   xD2
01AB4:  CLRF   xD3
01AB6:  CLRF   xD4
01AB8:  CLRF   xD5
01ABA:  CLRF   xD6
01ABC:  MOVLB  0
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
01ABE:  MOVFF  4CB,03
01AC2:  MOVLB  4
01AC4:  MOVF   xCA,W
01AC6:  MOVWF  FE9
01AC8:  MOVFF  03,FEA
01ACC:  MOVF   FEF,W
01ACE:  XORLW  0A
01AD0:  MOVLB  0
01AD2:  BZ    1ADA
01AD4:  XORLW  07
01AD6:  BZ    1AEA
01AD8:  BRA    1AF0
....................          case '\n': 
....................             y += 7*size + 1; 
01ADA:  MOVLB  4
01ADC:  MOVF   xCC,W
01ADE:  MULLW  07
01AE0:  MOVF   FF3,W
01AE2:  ADDLW  01
01AE4:  ADDWF  xC9,F
....................             continue; 
01AE6:  BRA    1B88
01AE8:  MOVLB  0
....................          case '\r': 
....................             x = 0; 
01AEA:  MOVLB  4
01AEC:  CLRF   xC8
....................             continue; 
01AEE:  BRA    1B88
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
01AF0:  MOVLB  4
01AF2:  MOVF   xCC,W
01AF4:  MULLW  05
01AF6:  MOVF   FF3,W
01AF8:  ADDWF  xC8,W
01AFA:  SUBLW  7F
01AFC:  BC    1B0A
....................       { 
....................          x = 0;                           // Set x at far left position 
01AFE:  CLRF   xC8
....................          y += 7*size + 1;                 // Set y at next position down 
01B00:  MOVF   xCC,W
01B02:  MULLW  07
01B04:  MOVF   FF3,W
01B06:  ADDLW  01
01B08:  ADDWF  xC9,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
01B0A:  CLRF   xCE
01B0C:  MOVF   xCE,W
01B0E:  SUBLW  04
01B10:  BNC   1B88
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
01B12:  CLRF   xCF
01B14:  MOVF   xCF,W
01B16:  SUBLW  06
01B18:  BNC   1B80
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
01B1A:  CLRF   03
01B1C:  MOVF   xCE,W
01B1E:  ADDLW  D2
01B20:  MOVWF  FE9
01B22:  MOVLW  04
01B24:  ADDWFC 03,W
01B26:  MOVWF  FEA
01B28:  MOVFF  FEF,4D7
01B2C:  MOVFF  4D7,00
01B30:  MOVF   xCF,W
01B32:  MOVWF  01
01B34:  BZ    1B3E
01B36:  BCF    FD8.0
01B38:  RRCF   00,F
01B3A:  DECFSZ 01,F
01B3C:  BRA    1B36
01B3E:  BTFSS  00.0
01B40:  BRA    1B7C
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
01B42:  CLRF   xD0
01B44:  MOVF   xCC,W
01B46:  SUBWF  xD0,W
01B48:  BC    1B7C
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
01B4A:  CLRF   xD1
01B4C:  MOVF   xCC,W
01B4E:  SUBWF  xD1,W
01B50:  BC    1B78
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
01B52:  MOVF   xD1,W
01B54:  ADDWF  xC8,W
01B56:  MOVWF  xD7
01B58:  MOVF   xCF,W
01B5A:  MULWF  xCC
01B5C:  MOVF   FF3,W
01B5E:  ADDWF  xC9,W
01B60:  ADDWF  xD0,W
01B62:  MOVWF  xD8
01B64:  MOVFF  4D7,4D9
01B68:  MOVWF  xDA
01B6A:  MOVFF  4CD,4DB
01B6E:  MOVLB  0
01B70:  RCALL  1936
....................                   } 
01B72:  MOVLB  4
01B74:  INCF   xD1,F
01B76:  BRA    1B4C
....................                } 
01B78:  INCF   xD0,F
01B7A:  BRA    1B44
....................             } 
....................          } 
01B7C:  INCF   xCF,F
01B7E:  BRA    1B14
....................       } 
01B80:  INCF   xCE,F
01B82:  MOVF   xCC,W
01B84:  ADDWF  xC8,F
01B86:  BRA    1B0C
....................    } 
01B88:  INCF   xCA,F
01B8A:  BTFSC  FD8.2
01B8C:  INCF   xCB,F
01B8E:  INCF   xC8,F
01B90:  MOVLB  0
01B92:  BRA    19F2
01B94:  MOVLB  4
.................... } 
01B96:  MOVLB  0
01B98:  RETURN 0
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "lobo.h" 
.................... //------------------------------------------------------------------------------ 
.................... // File generated by LCD Assistant 
.................... // http://en.radzio.dxp.pl/bitmap_converter/ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... const unsigned char lobo [] = { 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x30, 0x30, 0x70, 0xE0, 0xE0, 0xE0, 0xE0, 0x60, 0x60, 0x60, 0x60, 0x62, 0x62, 0x86, 0xCE, 0x8C, 
.................... 0xB4, 0xF4, 0xF4, 0xF8, 0xE8, 0x68, 0x78, 0x68, 0x68, 0x78, 0x78, 0xD8, 0xD8, 0x18, 0x0C, 0x04, 
.................... 0x04, 0x04, 0x04, 0x0C, 0x1C, 0x18, 0x98, 0xD8, 0xD8, 0xD8, 0xD8, 0xD0, 0xB0, 0xB0, 0x70, 0x70, 
.................... 0x70, 0x70, 0x60, 0xE0, 0xE0, 0x60, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x18, 0x30, 0x30, 0x30, 0x30, 0xB0, 
.................... 0xD0, 0xD0, 0x50, 0x50, 0x50, 0x50, 0xD8, 0xC9, 0x6B, 0x6B, 0x1F, 0x0D, 0x0D, 0x05, 0x05, 0x05, 
.................... 0xB9, 0xB9, 0xCD, 0x44, 0x44, 0x40, 0x47, 0x47, 0xCB, 0xCB, 0x59, 0x11, 0x11, 0x65, 0x7D, 0x5D, 
.................... 0x96, 0x96, 0x94, 0x34, 0x34, 0x27, 0x27, 0x26, 0x24, 0x26, 0xAE, 0xA6, 0xA6, 0x6B, 0xEB, 0x8A, 
.................... 0x10, 0x10, 0x18, 0x68, 0x68, 0x34, 0xB4, 0x84, 0x84, 0x84, 0x4C, 0x54, 0x54, 0xF4, 0xEE, 0xAE, 
.................... 0xBA, 0xBA, 0x1A, 0x4E, 0x4E, 0x6F, 0x6E, 0x6C, 0x5B, 0x5B, 0x56, 0x96, 0x96, 0x96, 0x16, 0x14, 
.................... 0x14, 0x34, 0x24, 0x64, 0x64, 0x88, 0x18, 0x18, 0x28, 0xE8, 0xE8, 0x38, 0x38, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0xC0, 0xC0, 0xC0, 0x40, 0x40, 0x40, 
.................... 0x41, 0x41, 0x41, 0x23, 0x27, 0xBA, 0xFE, 0x7E, 0x3E, 0x36, 0x26, 0xF6, 0xF6, 0xE3, 0xF7, 0xBF, 
.................... 0x80, 0x80, 0x80, 0xE0, 0xE0, 0x39, 0x39, 0x0D, 0x07, 0x07, 0x03, 0x86, 0x86, 0xFA, 0xFE, 0x7F, 
.................... 0x41, 0x41, 0x40, 0x40, 0x60, 0xE0, 0xF0, 0x70, 0x3F, 0x3F, 0x18, 0x18, 0x18, 0x18, 0xF8, 0xF0, 
.................... 0x1C, 0x1D, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x0D, 0x07, 0x03, 0x01, 0x61, 0x60, 
.................... 0x9C, 0xDC, 0xCE, 0xE7, 0xF7, 0x39, 0xF9, 0xCC, 0x4E, 0x4E, 0x5B, 0x9B, 0x9B, 0x8C, 0xBC, 0xBC, 
.................... 0x2D, 0x3D, 0x1D, 0x79, 0x7B, 0x5B, 0x36, 0x26, 0xEC, 0xEC, 0xAC, 0x58, 0x58, 0xF9, 0xB3, 0x33, 
.................... 0xAE, 0xAE, 0x6C, 0x3C, 0x3C, 0x1D, 0x06, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x18, 0x18, 0x28, 0x28, 0x28, 0xA4, 0xA4, 0xC4, 0xF2, 0xB2, 0x8D, 0x8F, 0x87, 
.................... 0x86, 0x86, 0x86, 0x85, 0x85, 0xE4, 0xF4, 0x74, 0x2C, 0x2C, 0x23, 0x20, 0x20, 0x20, 0x60, 0xF0, 
.................... 0x9A, 0x9A, 0x87, 0x83, 0x83, 0x42, 0xC2, 0xC2, 0x62, 0x62, 0x3F, 0x33, 0x33, 0x10, 0x10, 0x10, 
.................... 0xD0, 0xD0, 0x70, 0x1E, 0x1E, 0x0B, 0x0B, 0x08, 0x08, 0x08, 0x88, 0xFC, 0xFC, 0x84, 0x87, 0x83, 
.................... 0x82, 0x82, 0x82, 0xC2, 0x42, 0xE2, 0xFF, 0xDF, 0x41, 0xC1, 0xC0, 0xC0, 0x40, 0x60, 0x70, 0x30, 
.................... 0x9B, 0x9B, 0x40, 0x41, 0x41, 0x27, 0x25, 0x24, 0x29, 0x69, 0x49, 0x91, 0x91, 0x36, 0x3F, 0x2F, 
.................... 0xCA, 0x5A, 0x52, 0x1E, 0x1E, 0x3C, 0xE4, 0xE4, 0x14, 0x14, 0x0C, 0x00, 0x00, 0x01, 0x01, 0x01, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x3C, 0x1B, 0x13, 0x11, 0x11, 0x11, 
.................... 0xD1, 0xD9, 0x39, 0x1F, 0x1F, 0x11, 0x10, 0x10, 0x10, 0x10, 0xD0, 0xFC, 0xFE, 0x47, 0x43, 0x43, 
.................... 0x41, 0x41, 0xC1, 0x41, 0x41, 0x38, 0x3F, 0x2F, 0x20, 0x20, 0x10, 0x90, 0x90, 0x70, 0x78, 0x18, 
.................... 0x0F, 0x0F, 0x06, 0x06, 0x06, 0x06, 0xFE, 0xFC, 0x07, 0x07, 0x03, 0x01, 0x01, 0x91, 0xBB, 0xBF, 
.................... 0xD1, 0xD1, 0x71, 0x10, 0x10, 0xDB, 0xF9, 0x29, 0xFF, 0xFF, 0xE1, 0x18, 0x18, 0x07, 0x03, 0x03, 
.................... 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x06, 0x36, 0x36, 
.................... 0x1E, 0x1E, 0x0B, 0x08, 0x0C, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 
.................... 0x03, 0x03, 0x01, 0x01, 0x01, 0xC1, 0xE1, 0xF1, 0x6F, 0x6F, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 
.................... 0xF0, 0xF0, 0x1F, 0x30, 0x30, 0x30, 0x30, 0x30, 0x38, 0x18, 0x08, 0xFD, 0xFD, 0x0E, 0x0E, 0x04, 
.................... 0x84, 0x84, 0x86, 0x82, 0x82, 0xC3, 0xC3, 0xE1, 0xFF, 0xFF, 0x01, 0xF1, 0xF1, 0x19, 0x1D, 0x04, 
.................... 0x07, 0x0F, 0x7C, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1E, 
.................... 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0xF8, 0xF8, 0x08, 0x08, 0x06, 0x03, 0x03, 0xC2, 0xC2, 0x42, 
.................... 0x7F, 0x7F, 0xE1, 0x39, 0x39, 0x04, 0x06, 0x02, 0x03, 0x03, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x3E, 0x03, 0x01, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
.................... }; 
....................  
....................  
....................  
.................... void PrintLogo(void){ 
*
01CFE:  MOVLB  4
01D00:  CLRF   xC9
01D02:  CLRF   xC8
01D04:  CLRF   xCB
01D06:  CLRF   xCA
01D08:  CLRF   xCD
01D0A:  CLRF   xCC
01D0C:  CLRF   xCF
01D0E:  CLRF   xCE
01D10:  CLRF   xD1
01D12:  CLRF   xD0
.................... int16 h=0,i=0,j=0,k=0,l=0; 
.................... glcd_fillScreen(OFF); 
01D14:  CLRF   xD2
01D16:  MOVLB  0
01D18:  RCALL  1732
....................    for(h=0;h<8;h++){ 
01D1A:  MOVLB  4
01D1C:  CLRF   xC9
01D1E:  CLRF   xC8
01D20:  MOVF   xC9,F
01D22:  BNZ   1DE6
01D24:  MOVF   xC8,W
01D26:  SUBLW  07
01D28:  BNC   1DE6
....................       for(i=0;i<64;i++)displayData.left[j++]=lobo[l++];  
01D2A:  CLRF   xCB
01D2C:  CLRF   xCA
01D2E:  MOVF   xCB,F
01D30:  BNZ   1D84
01D32:  MOVF   xCA,W
01D34:  SUBLW  3F
01D36:  BNC   1D84
01D38:  MOVFF  4CD,03
01D3C:  MOVF   xCC,W
01D3E:  INCF   xCC,F
01D40:  BTFSC  FD8.2
01D42:  INCF   xCD,F
01D44:  MOVWF  xD2
01D46:  MOVFF  03,4D3
01D4A:  MOVLW  BB
01D4C:  ADDWF  xD2,W
01D4E:  MOVWF  FE9
01D50:  MOVLW  00
01D52:  ADDWFC 03,W
01D54:  MOVWF  FEA
01D56:  MOVFF  4D1,03
01D5A:  MOVF   xD0,W
01D5C:  INCF   xD0,F
01D5E:  BTFSC  FD8.2
01D60:  INCF   xD1,F
01D62:  MOVWF  xD6
01D64:  MOVFF  03,4D7
01D68:  MOVFF  03,03
01D6C:  MOVF   xD6,W
01D6E:  MOVFF  03,FF7
01D72:  MOVLB  0
01D74:  CALL   120C
01D78:  MOVWF  FEF
01D7A:  MOVLB  4
01D7C:  INCF   xCA,F
01D7E:  BTFSC  FD8.2
01D80:  INCF   xCB,F
01D82:  BRA    1D2E
....................       for(i=0;i<64;i++)displayData.right[k++]=lobo[l++];  
01D84:  CLRF   xCB
01D86:  CLRF   xCA
01D88:  MOVF   xCB,F
01D8A:  BNZ   1DDE
01D8C:  MOVF   xCA,W
01D8E:  SUBLW  3F
01D90:  BNC   1DDE
01D92:  MOVFF  4CF,03
01D96:  MOVF   xCE,W
01D98:  INCF   xCE,F
01D9A:  BTFSC  FD8.2
01D9C:  INCF   xCF,F
01D9E:  MOVWF  xD2
01DA0:  MOVFF  03,4D3
01DA4:  MOVLW  BB
01DA6:  ADDWF  xD2,W
01DA8:  MOVWF  FE9
01DAA:  MOVLW  02
01DAC:  ADDWFC 03,W
01DAE:  MOVWF  FEA
01DB0:  MOVFF  4D1,03
01DB4:  MOVF   xD0,W
01DB6:  INCF   xD0,F
01DB8:  BTFSC  FD8.2
01DBA:  INCF   xD1,F
01DBC:  MOVWF  xD6
01DBE:  MOVFF  03,4D7
01DC2:  MOVFF  03,03
01DC6:  MOVF   xD6,W
01DC8:  MOVFF  03,FF7
01DCC:  MOVLB  0
01DCE:  CALL   120C
01DD2:  MOVWF  FEF
01DD4:  MOVLB  4
01DD6:  INCF   xCA,F
01DD8:  BTFSC  FD8.2
01DDA:  INCF   xCB,F
01DDC:  BRA    1D88
....................    } 
01DDE:  INCF   xC8,F
01DE0:  BTFSC  FD8.2
01DE2:  INCF   xC9,F
01DE4:  BRA    1D20
.................... } 
01DE6:  MOVLB  0
01DE8:  GOTO   28A6 (RETURN)
....................  
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... #zero_ram 
.................... void main(){ 
*
02688:  CLRF   FF8
0268A:  BCF    FD0.7
0268C:  MOVLB  E
0268E:  MOVLW  55
02690:  MOVWF  FA7
02692:  MOVLW  AA
02694:  MOVWF  FA7
02696:  BCF    xBF.0
02698:  MOVLW  14
0269A:  MOVWF  xF7
0269C:  MOVLW  06
0269E:  MOVWF  xD3
026A0:  MOVLW  55
026A2:  MOVWF  FA7
026A4:  MOVLW  AA
026A6:  MOVWF  FA7
026A8:  BSF    xBF.0
026AA:  MOVLW  AE
026AC:  MOVWF  00
026AE:  MOVLW  0F
026B0:  MOVWF  01
026B2:  MOVLW  02
026B4:  MOVWF  FE9
026B6:  MOVLW  00
026B8:  MOVWF  FEA
026BA:  CLRF   FEE
026BC:  DECFSZ 00,F
026BE:  BRA    26BA
026C0:  DECFSZ 01,F
026C2:  BRA    26BA
026C4:  CLRF   FEA
026C6:  CLRF   FE9
026C8:  CLRF   2C
026CA:  MOVLW  37
026CC:  MOVLB  0
026CE:  MOVWF  xB6
026D0:  MOVLB  4
026D2:  CLRF   xBC
026D4:  CLRF   xBB
026D6:  MOVLB  1
026D8:  CLRF   x88
026DA:  MOVLW  FF
026DC:  MOVLB  F
026DE:  MOVWF  x48
026E0:  BCF    FC2.6
026E2:  BCF    FC2.7
026E4:  MOVF   x49,W
026E6:  ANDLW  E0
026E8:  IORLW  1F
026EA:  MOVWF  x49
026EC:  CLRF   x25
026EE:  CLRF   FD1
026F0:  CLRF   FD2
.................... float valor; 
.................... char valor2[7]; //Con esta variable visualizar un dato en pantalla// 
.................... mcu_init();   
026F2:  BSF    F9B.6
.................... set_tris_e(0b00000000); 
026F4:  BCF    F96.0
026F6:  BCF    F96.1
026F8:  BCF    F96.2
.................... set_tris_d(0b00000000); 
026FA:  MOVLW  00
026FC:  MOVWF  F95
.................... set_tris_c(0b00000000); 
026FE:  MOVWF  F94
.................... set_tris_a(0b00000111);   
02700:  MOVLW  07
02702:  MOVWF  F92
....................                               // Inicializa microcontrolador 
.................... SETUP_ADC_PORTS(sAN0 | sAN1 | sAN2);                        // ADC deshabilitado 
02704:  MOVLW  F8
02706:  MOVWF  x48
02708:  BCF    FC2.6
0270A:  BCF    FC2.7
0270C:  MOVF   x49,W
0270E:  ANDLW  E0
02710:  IORLW  1F
02712:  MOVWF  x49
.................... SETUP_ADC(ADC_CLOCK_INTERNAL);               // Todos los puertos como dgitales 
02714:  MOVF   FC1,W
02716:  ANDLW  C0
02718:  IORLW  03
0271A:  MOVWF  FC1
0271C:  BCF    FC1.7
0271E:  BSF    FC2.0
02720:  BSF    FC2.7
02722:  BSF    FC2.1
02724:  BTFSC  FC2.1
02726:  BRA    2724
02728:  BCF    FC2.7
....................  
.................... glcd_init(ON);                             // Inicializa pantalla GLCD 
0272A:  MOVLW  01
0272C:  MOVLB  4
0272E:  MOVWF  xC8
02730:  MOVLB  0
02732:  GOTO   1844
.................... glcd_fillScreen(OFF);                      // Pantalla GLCD fondo Blanco 
02736:  MOVLB  4
02738:  CLRF   xD2
0273A:  MOVLB  0
0273C:  CALL   1732
....................  
.................... sprintf(text_glcd,"Guillermo acevedo"); 
02740:  MOVLB  4
02742:  CLRF   xBC
02744:  MOVLW  04
02746:  MOVWF  xBB
02748:  MOVLW  1E
0274A:  MOVWF  FF6
0274C:  MOVLW  16
0274E:  MOVWF  FF7
02750:  MOVLW  00
02752:  MOVWF  FF8
02754:  MOVLB  0
02756:  CALL   190E
.................... glcd_text57(4, 4, text_glcd, 1, ON);       // Imprime texto 
0275A:  MOVLW  04
0275C:  MOVLB  4
0275E:  MOVWF  xC8
02760:  MOVWF  xC9
02762:  CLRF   xCB
02764:  MOVWF  xCA
02766:  MOVLW  01
02768:  MOVWF  xCC
0276A:  MOVWF  xCD
0276C:  MOVLB  0
0276E:  CALL   19F2
.................... glcd_line(0, 15, 127, 15, ON) ;            // Ejemplo para dibujar linea 
02772:  MOVLB  4
02774:  CLRF   xC8
02776:  MOVLW  0F
02778:  MOVWF  xC9
0277A:  MOVLW  7F
0277C:  MOVWF  xCA
0277E:  MOVLW  0F
02780:  MOVWF  xCB
02782:  MOVLW  01
02784:  MOVWF  xCC
02786:  MOVLB  0
02788:  CALL   1B9A
.................... sprintf(text_glcd,"Walter Moreno"); 
0278C:  MOVLB  4
0278E:  CLRF   xBC
02790:  MOVLW  04
02792:  MOVWF  xBB
02794:  MOVLW  30
02796:  MOVWF  FF6
02798:  MOVLW  16
0279A:  MOVWF  FF7
0279C:  MOVLW  00
0279E:  MOVWF  FF8
027A0:  MOVLB  0
027A2:  CALL   190E
.................... glcd_text57(4, 17, text_glcd, 1, ON);       // Imprime texto 
027A6:  MOVLW  04
027A8:  MOVLB  4
027AA:  MOVWF  xC8
027AC:  MOVLW  11
027AE:  MOVWF  xC9
027B0:  CLRF   xCB
027B2:  MOVLW  04
027B4:  MOVWF  xCA
027B6:  MOVLW  01
027B8:  MOVWF  xCC
027BA:  MOVWF  xCD
027BC:  MOVLB  0
027BE:  CALL   19F2
.................... glcd_line(0, 28, 127, 28, ON) ;   
027C2:  MOVLB  4
027C4:  CLRF   xC8
027C6:  MOVLW  1C
027C8:  MOVWF  xC9
027CA:  MOVLW  7F
027CC:  MOVWF  xCA
027CE:  MOVLW  1C
027D0:  MOVWF  xCB
027D2:  MOVLW  01
027D4:  MOVWF  xCC
027D6:  MOVLB  0
027D8:  CALL   1B9A
.................... sprintf(text_glcd,"ola k asen"); 
027DC:  MOVLB  4
027DE:  CLRF   xBC
027E0:  MOVLW  04
027E2:  MOVWF  xBB
027E4:  MOVLW  3E
027E6:  MOVWF  FF6
027E8:  MOVLW  16
027EA:  MOVWF  FF7
027EC:  MOVLW  00
027EE:  MOVWF  FF8
027F0:  MOVLB  0
027F2:  CALL   190E
.................... glcd_text57(4, 30, text_glcd, 1, ON);   
027F6:  MOVLW  04
027F8:  MOVLB  4
027FA:  MOVWF  xC8
027FC:  MOVLW  1E
027FE:  MOVWF  xC9
02800:  CLRF   xCB
02802:  MOVLW  04
02804:  MOVWF  xCA
02806:  MOVLW  01
02808:  MOVWF  xCC
0280A:  MOVWF  xCD
0280C:  MOVLB  0
0280E:  CALL   19F2
.................... glcd_line(0, 41, 127, 41, ON) ;  
02812:  MOVLB  4
02814:  CLRF   xC8
02816:  MOVLW  29
02818:  MOVWF  xC9
0281A:  MOVLW  7F
0281C:  MOVWF  xCA
0281E:  MOVLW  29
02820:  MOVWF  xCB
02822:  MOVLW  01
02824:  MOVWF  xCC
02826:  MOVLB  0
02828:  CALL   1B9A
.................... sprintf(text_glcd,"Winter is coming"); 
0282C:  MOVLB  4
0282E:  CLRF   xBC
02830:  MOVLW  04
02832:  MOVWF  xBB
02834:  MOVLW  4A
02836:  MOVWF  FF6
02838:  MOVLW  16
0283A:  MOVWF  FF7
0283C:  MOVLW  00
0283E:  MOVWF  FF8
02840:  MOVLB  0
02842:  CALL   190E
.................... glcd_text57(4, 42, text_glcd, 1, ON);   
02846:  MOVLW  04
02848:  MOVLB  4
0284A:  MOVWF  xC8
0284C:  MOVLW  2A
0284E:  MOVWF  xC9
02850:  CLRF   xCB
02852:  MOVLW  04
02854:  MOVWF  xCA
02856:  MOVLW  01
02858:  MOVWF  xCC
0285A:  MOVWF  xCD
0285C:  MOVLB  0
0285E:  CALL   19F2
.................... glcd_line(0, 53, 127, 53, ON) ;  
02862:  MOVLB  4
02864:  CLRF   xC8
02866:  MOVLW  35
02868:  MOVWF  xC9
0286A:  MOVLW  7F
0286C:  MOVWF  xCA
0286E:  MOVLW  35
02870:  MOVWF  xCB
02872:  MOVLW  01
02874:  MOVWF  xCC
02876:  MOVLB  0
02878:  CALL   1B9A
.................... glcd_update();                             // Actualiza pantalla 
0287C:  CALL   178C
....................  
.................... delay_ms(300);                            
02880:  MOVLW  02
02882:  MOVLB  4
02884:  MOVWF  xC8
02886:  MOVLW  96
02888:  MOVWF  xC9
0288A:  MOVLB  0
0288C:  CALL   1CD4
02890:  MOVLB  4
02892:  DECFSZ xC8,F
02894:  BRA    2886
.................... glcd_fillScreen(OFF);  
02896:  CLRF   xD2
02898:  MOVLB  0
0289A:  CALL   1732
.................... glcd_update();   
0289E:  CALL   178C
....................  
.................... PrintLogo();                               // Imprime Logo en Pantalla 
028A2:  GOTO   1CFE
.................... glcd_update();                             // Actualiza pantalla 
028A6:  CALL   178C
.................... delay_ms(400);                            
028AA:  MOVLW  02
028AC:  MOVLB  4
028AE:  MOVWF  xC8
028B0:  MOVLW  C8
028B2:  MOVWF  xC9
028B4:  MOVLB  0
028B6:  CALL   1CD4
028BA:  MOVLB  4
028BC:  DECFSZ xC8,F
028BE:  BRA    28B0
.................... glcd_fillScreen(OFF);  
028C0:  CLRF   xD2
028C2:  MOVLB  0
028C4:  CALL   1732
....................  
.................... for (i=0; i<120;i++){ 
028C8:  CLRF   xBA
028CA:  BTFSC  xBA.7
028CC:  BRA    28D4
028CE:  MOVF   xBA,W
028D0:  SUBLW  77
028D2:  BNC   28EA
.................... 	vector[i]=55; 
028D4:  CLRF   03
028D6:  MOVF   xBA,W
028D8:  ADDLW  3D
028DA:  MOVWF  FE9
028DC:  MOVLW  00
028DE:  ADDWFC 03,W
028E0:  MOVWF  FEA
028E2:  MOVLW  37
028E4:  MOVWF  FEF
.................... } 
028E6:  INCF   xBA,F
028E8:  BRA    28CA
....................  
.................... while(TRUE) 
.................... {	 
.................... 	glcd_fillScreen(OFF); 
028EA:  MOVLB  4
028EC:  CLRF   xD2
028EE:  MOVLB  0
028F0:  CALL   1732
.................... 	glcd_update(); 
028F4:  CALL   178C
.................... 	set_adc_channel(0); 
028F8:  MOVLW  00
028FA:  MOVWF  01
028FC:  MOVF   FC2,W
028FE:  ANDLW  C3
02900:  IORWF  01,W
02902:  MOVWF  FC2
.................... 	delay_us(100); 
02904:  MOVLW  64
02906:  MOVLB  4
02908:  MOVWF  xC8
0290A:  MOVLB  0
0290C:  CALL   1DEC
.................... 	sensor1=read_adc(); 
02910:  BSF    FC2.1
02912:  BTFSC  FC2.1
02914:  BRA    2912
02916:  MOVFF  FC4,3A
.................... 	set_adc_channel(1); 
0291A:  MOVLW  04
0291C:  MOVWF  01
0291E:  MOVF   FC2,W
02920:  ANDLW  C3
02922:  IORWF  01,W
02924:  MOVWF  FC2
.................... 	delay_us(100); 
02926:  MOVLW  64
02928:  MOVLB  4
0292A:  MOVWF  xC8
0292C:  MOVLB  0
0292E:  CALL   1DEC
.................... 	sensor2=read_adc(); 
02932:  BSF    FC2.1
02934:  BTFSC  FC2.1
02936:  BRA    2934
02938:  MOVFF  FC4,3B
.................... 	set_adc_channel(2); 
0293C:  MOVLW  08
0293E:  MOVWF  01
02940:  MOVF   FC2,W
02942:  ANDLW  C3
02944:  IORWF  01,W
02946:  MOVWF  FC2
.................... 	delay_us(100); 
02948:  MOVLW  64
0294A:  MOVLB  4
0294C:  MOVWF  xC8
0294E:  MOVLB  0
02950:  CALL   1DEC
.................... 	sensor3=read_adc(); 
02954:  BSF    FC2.1
02956:  BTFSC  FC2.1
02958:  BRA    2956
0295A:  MOVFF  FC4,3C
.................... 	prom=(sensor1+sensor2+sensor3)/3; 
0295E:  MOVF   3B,W
02960:  ADDWF  3A,W
02962:  ADDWF  3C,W
02964:  MOVLB  4
02966:  MOVWF  xC9
02968:  MOVWF  xCA
0296A:  MOVLW  03
0296C:  MOVWF  xCB
0296E:  MOVLB  0
02970:  GOTO   1E12
02974:  MOVF   01,W
02976:  MOVLB  4
02978:  CLRF   xC9
0297A:  MOVWF  xC8
0297C:  MOVLB  0
0297E:  GOTO   1E40
02982:  MOVFF  03,39
02986:  MOVFF  02,38
0298A:  MOVFF  01,37
0298E:  MOVFF  00,36
.................... 	calculo=prom*0.0124; 
02992:  MOVFF  39,4D8
02996:  MOVFF  38,4D7
0299A:  MOVFF  37,4D6
0299E:  MOVFF  36,4D5
029A2:  MOVLW  5F
029A4:  MOVLB  4
029A6:  MOVWF  xDC
029A8:  MOVLW  29
029AA:  MOVWF  xDB
029AC:  MOVLW  4B
029AE:  MOVWF  xDA
029B0:  MOVLW  78
029B2:  MOVWF  xD9
029B4:  MOVLB  0
029B6:  CALL   1E78
029BA:  MOVFF  03,31
029BE:  MOVFF  02,30
029C2:  MOVFF  01,2F
029C6:  MOVFF  00,2E
.................... 	temp=calculo/0.010; 
029CA:  MOVFF  31,4CB
029CE:  MOVFF  30,4CA
029D2:  MOVFF  2F,4C9
029D6:  MOVFF  2E,4C8
029DA:  MOVLW  0A
029DC:  MOVLB  4
029DE:  MOVWF  xCF
029E0:  MOVLW  D7
029E2:  MOVWF  xCE
029E4:  MOVLW  23
029E6:  MOVWF  xCD
029E8:  MOVLW  78
029EA:  MOVWF  xCC
029EC:  MOVLB  0
029EE:  CALL   1F6E
029F2:  MOVFF  03,35
029F6:  MOVFF  02,34
029FA:  MOVFF  01,33
029FE:  MOVFF  00,32
.................... 	sprintf(valor2, "%f", temp); 
02A02:  MOVLW  04
02A04:  MOVLB  4
02A06:  MOVWF  xBC
02A08:  MOVLW  C1
02A0A:  MOVWF  xBB
02A0C:  MOVLW  89
02A0E:  MOVWF  FE9
02A10:  MOVFF  35,4CB
02A14:  MOVFF  34,4CA
02A18:  MOVFF  33,4C9
02A1C:  MOVFF  32,4C8
02A20:  MOVLW  02
02A22:  MOVWF  xCC
02A24:  MOVLB  0
02A26:  GOTO   21A4
.................... 	glcd_text57(30,0, valor2,1,ON); 
02A2A:  MOVLW  1E
02A2C:  MOVLB  4
02A2E:  MOVWF  xC8
02A30:  CLRF   xC9
02A32:  MOVLW  04
02A34:  MOVWF  xCB
02A36:  MOVLW  C1
02A38:  MOVWF  xCA
02A3A:  MOVLW  01
02A3C:  MOVWF  xCC
02A3E:  MOVWF  xCD
02A40:  MOVLB  0
02A42:  CALL   19F2
.................... 	glcd_update(); 
02A46:  CALL   178C
....................  	glcd_line(7, 55, 127, 55, ON) ;   
02A4A:  MOVLW  07
02A4C:  MOVLB  4
02A4E:  MOVWF  xC8
02A50:  MOVLW  37
02A52:  MOVWF  xC9
02A54:  MOVLW  7F
02A56:  MOVWF  xCA
02A58:  MOVLW  37
02A5A:  MOVWF  xCB
02A5C:  MOVLW  01
02A5E:  MOVWF  xCC
02A60:  MOVLB  0
02A62:  CALL   1B9A
.................... 	glcd_line(7, 0, 7, 55, ON) ; 
02A66:  MOVLW  07
02A68:  MOVLB  4
02A6A:  MOVWF  xC8
02A6C:  CLRF   xC9
02A6E:  MOVWF  xCA
02A70:  MOVLW  37
02A72:  MOVWF  xCB
02A74:  MOVLW  01
02A76:  MOVWF  xCC
02A78:  MOVLB  0
02A7A:  CALL   1B9A
.................... 	sprintf(text_glcd,"t"); 
02A7E:  MOVLB  4
02A80:  CLRF   xBC
02A82:  MOVLW  04
02A84:  MOVWF  xBB
02A86:  MOVLW  74
02A88:  MOVWF  xD5
02A8A:  MOVLB  0
02A8C:  CALL   18EE
.................... 	glcd_text57(120, 57, text_glcd, 1, ON);       // Imprime texto 
02A90:  MOVLW  78
02A92:  MOVLB  4
02A94:  MOVWF  xC8
02A96:  MOVLW  39
02A98:  MOVWF  xC9
02A9A:  CLRF   xCB
02A9C:  MOVLW  04
02A9E:  MOVWF  xCA
02AA0:  MOVLW  01
02AA2:  MOVWF  xCC
02AA4:  MOVWF  xCD
02AA6:  MOVLB  0
02AA8:  CALL   19F2
.................... 	sprintf(text_glcd,"T"); 
02AAC:  MOVLB  4
02AAE:  CLRF   xBC
02AB0:  MOVLW  04
02AB2:  MOVWF  xBB
02AB4:  MOVLW  54
02AB6:  MOVWF  xD5
02AB8:  MOVLB  0
02ABA:  CALL   18EE
.................... 	glcd_text57(0, 0, text_glcd, 1, ON);       // Imprime texto 
02ABE:  MOVLB  4
02AC0:  CLRF   xC8
02AC2:  CLRF   xC9
02AC4:  CLRF   xCB
02AC6:  MOVLW  04
02AC8:  MOVWF  xCA
02ACA:  MOVLW  01
02ACC:  MOVWF  xCC
02ACE:  MOVWF  xCD
02AD0:  MOVLB  0
02AD2:  CALL   19F2
.................... 	vector[119]=50-(prom/2); 
02AD6:  MOVFF  39,4CB
02ADA:  MOVFF  38,4CA
02ADE:  MOVFF  37,4C9
02AE2:  MOVFF  36,4C8
02AE6:  MOVLB  4
02AE8:  CLRF   xCF
02AEA:  CLRF   xCE
02AEC:  CLRF   xCD
02AEE:  MOVLW  80
02AF0:  MOVWF  xCC
02AF2:  MOVLB  0
02AF4:  CALL   1F6E
02AF8:  BSF    FD8.1
02AFA:  MOVLB  4
02AFC:  CLRF   xCB
02AFE:  CLRF   xCA
02B00:  MOVLW  48
02B02:  MOVWF  xC9
02B04:  MOVLW  84
02B06:  MOVWF  xC8
02B08:  MOVFF  03,4CF
02B0C:  MOVFF  02,4CE
02B10:  MOVFF  01,4CD
02B14:  MOVFF  00,4CC
02B18:  MOVLB  0
02B1A:  BRA    2354
02B1C:  MOVFF  03,4CB
02B20:  MOVFF  02,4CA
02B24:  MOVFF  01,4C9
02B28:  MOVFF  00,4C8
02B2C:  BRA    25CE
02B2E:  MOVFF  01,B4
.................... 	posy=vector[119];	 
02B32:  MOVFF  B4,B6
.................... 	for (t=0; t<119;t++){ 
02B36:  CLRF   xB9
02B38:  BTFSC  xB9.7
02B3A:  BRA    2B42
02B3C:  MOVF   xB9,W
02B3E:  SUBLW  76
02B40:  BNC   2BAC
.................... 		vector[t]=vector[t+1]; 
02B42:  CLRF   03
02B44:  MOVF   xB9,W
02B46:  ADDLW  3D
02B48:  MOVWF  01
02B4A:  MOVLW  00
02B4C:  ADDWFC 03,F
02B4E:  MOVFF  03,4C9
02B52:  MOVLW  01
02B54:  MOVLB  0
02B56:  ADDWF  xB9,W
02B58:  CLRF   03
02B5A:  ADDLW  3D
02B5C:  MOVWF  FE9
02B5E:  MOVLW  00
02B60:  ADDWFC 03,W
02B62:  MOVWF  FEA
02B64:  MOVFF  FEF,4CA
02B68:  MOVLB  4
02B6A:  MOVFF  4C9,FEA
02B6E:  MOVFF  01,FE9
02B72:  MOVFF  4CA,FEF
.................... 		glcd_pixel(t+8,vector[t],ON); 
02B76:  MOVLW  08
02B78:  MOVLB  0
02B7A:  ADDWF  xB9,W
02B7C:  MOVLB  4
02B7E:  MOVWF  xC8
02B80:  CLRF   03
02B82:  MOVLB  0
02B84:  MOVF   xB9,W
02B86:  ADDLW  3D
02B88:  MOVWF  FE9
02B8A:  MOVLW  00
02B8C:  ADDWFC 03,W
02B8E:  MOVWF  FEA
02B90:  MOVFF  FEF,4C9
02B94:  MOVFF  4C8,4D9
02B98:  MOVFF  4C9,4DA
02B9C:  MOVLW  01
02B9E:  MOVLB  4
02BA0:  MOVWF  xDB
02BA2:  MOVLB  0
02BA4:  CALL   1936
.................... 	} 
02BA8:  INCF   xB9,F
02BAA:  BRA    2B38
.................... 	glcd_pixel(127,vector[119],ON); 
02BAC:  MOVLW  7F
02BAE:  MOVLB  4
02BB0:  MOVWF  xD9
02BB2:  MOVFF  B4,4DA
02BB6:  MOVLW  01
02BB8:  MOVWF  xDB
02BBA:  MOVLB  0
02BBC:  CALL   1936
.................... 	glcd_update(); 
02BC0:  CALL   178C
.................... 	 
....................     if(temp>=35){ 
02BC4:  MOVLB  4
02BC6:  CLRF   xCB
02BC8:  CLRF   xCA
02BCA:  MOVLW  0C
02BCC:  MOVWF  xC9
02BCE:  MOVLW  84
02BD0:  MOVWF  xC8
02BD2:  MOVFF  35,4CF
02BD6:  MOVFF  34,4CE
02BDA:  MOVFF  33,4CD
02BDE:  MOVFF  32,4CC
02BE2:  MOVLB  0
02BE4:  BRA    260C
02BE6:  BC    2BEA
02BE8:  BNZ   2BF0
....................       output_high(ventilador); 
02BEA:  BCF    F92.3
02BEC:  BSF    F89.3
.................... 	} 
.................... 	else{ 
02BEE:  BRA    2BF4
.................... 		output_low(ventilador); 
02BF0:  BCF    F92.3
02BF2:  BCF    F89.3
.................... 	} 
.................... 	delay_ms(100); 
02BF4:  MOVLW  64
02BF6:  MOVLB  4
02BF8:  MOVWF  xC9
02BFA:  MOVLB  0
02BFC:  CALL   1CD4
.................... 	glcd_fillScreen(OFF);  
02C00:  MOVLB  4
02C02:  CLRF   xD2
02C04:  MOVLB  0
02C06:  CALL   1732
.................... 	glcd_update(); 
02C0A:  CALL   178C
.................... } 
02C0E:  BRA    28EA
.................... } 
02C10:  SLEEP 

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
